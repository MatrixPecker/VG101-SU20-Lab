# Distinct Powers - Writeup

Please write down your writeup as follow format:
```markdown
## (Nickname) | (local running time) | (language)

Solution

Code (if available, in MATLAB)

Real name and other comment
```

[TOC]

## Scarlet | 0.367s | C++

Consider all the number $z_i(2\le z_i\le 10^5)$ that can't be represented as $x^y$ ($y>1$). They are

$$2,3,5,6,7,10,\dots$$

We just need to sum up the number of distinct $z_i^k$.

Valid $k$ can be found in the $\lfloor\log n\rfloor\times n$ table, in $n=10^5$ this case, they are

$$1,2,3,\cdots 100000\\2,4,6,\cdots 200000\\3,6,9,\cdots 300000\\\cdots$$

For each $z_i$, we can find the greatest $t$ s.t. $z_i^t<10^5$, we just want to know how many distinct numbers are there in the first $t$ lines of the above table. Calculate this number and add them up for each $z_i$, you will get the answer.

No available code in MATLAB :D (See lc's code)

Muchen Xu

## limlimg | 0.010766s | MATLAB

Solution is described in the comments of the code.

```Matlab
% revised chanllenge code
% time complexity O(log2(a)*(b + a^0.5))
% run time for a = 100000, b = 100000 case: < 0.1"
a = input("");
b = input("");
tic;

% for ai < aj in 2:a, only when aj = ai^n will their results of a^b
% collide. So two numbers are grouped together if one of them is the power
% of the other.

% The number of powers generated by a whole group is only dependent on its
% size. The mapping is provided by calcGroupValue beforehand.

GroupValue = calcGroupValue(a, b);
GroupRecord = zeros(fix(sqrt(a)), 1);

% firstly, put every number in individual groups. If a number was
% later found to be in another group marked by a smaller number, subtract
% the result then.
result = (int64(a)-1)*(int64(b)-1);

for i = 2:size(GroupRecord, 1)
% i above sqrt(a) are not check because they either form their own groups
% with no other number or belong to a group with number within sqrt(a)

    % if i doesn't belong to any group
    if GroupRecord(i)
        continue;
    end
    % then it must be the smallest number of its own group
    % count the size of this group
    PowerOfI = i;
    for j = 1:fix(log2(a))
        if(PowerOfI <= size(GroupRecord, 1))
            GroupRecord(PowerOfI) = i;
        end
        PowerOfI = PowerOfI * i;
        if PowerOfI > a
            break;
        end
    end
    % all numbers in this group were assumed to generate b-1 powers before
    % here replace the assumed sum with the actual sum
    result = result - j*GroupValue(1) + GroupValue(j);
end
disp(result);
toc;


function results = calcGroupValue(a, b)
% calculate the number of powers generated by a group containing 1 ... n
% members and return the result in a vector

% the values are only dependent on b and the biggest size of groups is
% determined by a, so once the inputs are given the results can be
% generated for repeated use.

    MaxSize = fix(log2(a));
    results = zeros(MaxSize, 1);
    record = int8([]);
    record(MaxSize * b, 1) = 0;
    for i = 1:MaxSize
        % construct a group in the order of a^1, a^2 ...
        % each member added results in the addition of the powers generated
        % by this group, so the result(n) = result(n-1) + f(n), where f(n)
        % is the number of distinct powers generated by a^n
        if i > 1
            results(i) = results(i-1);
        end
        for j = 2:b
            if record(i*j) == 0
                results(i) = results(i) + 1;
                record(i*j) = 1;
            end
        end
    end
end
```

YifanShen

## lc | 0.018473s | MATLAB
This program works in the way which is described by Muchen Xu.
```matlab
clearvars,clc;
num=input('n: ');
tic;
list=ones(1,num,'uint8');
su=zeros(1,num,'uint32');
cnt=zeros(1,num*20,'uint8');
record=zeros(20,'uint32');
for i=1:log2(num)
    cnt(int32(i)*int32((2:num)))=1;
    record(i)=sum(cnt,'all');
end
for i=2:num
    if list(i)>0
        t=2;
        while true
            if power(i,t)<=num
                list(power(i,t))=0;
                list(i)=list(i)+1;
                t=t+1;
            else
                break;
            end
        end
        su(i)=record(list(i));
    end
end
int64(sum(su,'all'))
toc;
```
Chang Liu

## Rip-Van-Winkle | 0.051941s | MATLAB
There still exist some places to improve. It is similar to what is described by Muchen Xu.
```matlab
n = input('');
count = 0;
k = 0;
mark = zeros(n,1);
mark2 = zeros(floor(log2(n)),1);
tic
for i = 2 : n 
    k = 0;
    if  mark(i) == 0
       while i ^ (k+1) <= n
           k = k + 1;
           mark(i ^(k - 1) , 1 ) = 1;
       end
       mark(i ^ k , 1 ) = 1;
       if mark2(k) ~= 0
           count = count + mark2(k);
       else
           hash = zeros(k * n,1);
           inner_cnt = 0;
           for j = 1 : k
               for a = 2 : n
                   if hash(a * j , 1) == 0
                       hash(a * j , 1) = 1;
                       count = count + 1;
                       inner_cnt = inner_cnt + 1;
                   end
               end
           end
           mark2(k) = inner_cnt;
       end
    end      
end    
fprintf('%.0f',count)
toc
```
Runqing Cai

## Acranker | 0.074s | C++11 -O2

The solution is similar to Scarlet.
```cpp
#include <bits/stdc++.h>
using namespace std;
#define gettime() printf("%.3f\n",(double)clock()/CLOCKS_PER_SEC)

typedef long long ll;
ll m[20];
unordered_map<ll,ll> mi;
bool f[1000050];
ll d[20];
ll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}
ll q_pow(ll a,ll b)
{
	ll ans=1;
	for(;b;b>>=1)
	{
		if(b&1) ans=ans*a;
		a=a*a;
	}
	return ans;
}
int main()
{
	ll a,b;
	cin>>a>>b;
	gettime();
	mi.clear();
	for(ll i=1;i<=16;i++)
	{
		for(ll j=2;j<=b;j++)
		{
			mi[j*i]=1;
		}
		m[i]=mi.size();
		//cout<<m[i]<<" ";
	}
	//cout<<endl;
	ll sq=sqrt(a);
	for(ll i=2;i<=sq;i++)
	{
		if(f[i]) continue;
		ll tmp=i,j;
		for(j=1;tmp<=a;j++)
		{
			if(tmp<=sq) f[tmp]=true;
			tmp*=i;
		}
		d[j-1]++;
	}
	d[1]=a-1;
	for(int i=2;i<=16;i++) d[1]-=d[i]*i;
	//for(int i=1;i<=16;i++) cout<<d[i]<<" ";cout<<endl;
	ll ans=0;
	for(ll i=1;i<=16;i++) ans+=m[i]*d[i];
	cout<<ans<<endl;
	gettime();
	return 0;
}
```

Neng Fan

## tonyfettes | 0.0156s | C++11 O3

This solution is based on Scarlet. Use mathematical method to calculate the repeated numbers when $t$ eqauls 2, 3, and 4 by hand.
The function `find_magic()` in code is to findout $z_i$ in Scarlet's solution, `lim` equals to the max possbile $t$.
I believe there exists one algorithm to solve all possible $t$ and express it use $n$, but it already take my too much time so I gave up.

This running time is got on Linux with PDS cpu scheduler and enabled soft realtime feature on CPU @ 2.20 GHz. So please don't take it so seriously.

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <vector>
#include <ctime>
using std::vector;

long long N;
vector<int> magic;
int vis[2000000];
int limcnt[20];
int mvis[100001];

long long power(int a, int b) {
  long long ans = 1;
  long long base = a;
  while (b != 0) {
    if (b & 1) ans *= base;
    base *= base;
    b >>= 1;
  }
  return ans;
}

void find_magic(int n) {
  magic.push_back(1);
  for (int i = 2; i <= n; i++) {
    if (!mvis[i]) magic.push_back(i);
    for (int j = 2; power(i, j) <= n; j++)
      mvis[power(i, j)] = 1;
  }
}

int main() {
  clock_t begin_time = clock();
  N = 100000;
  find_magic((int)sqrt(N));
  long long ans = 0;
  for (int base_index = 1; base_index < (int)magic.size(); base_index++) {
    int base = magic[base_index];
    int lim = floor(log2(N) / log2(base));
    if (lim == 2) {
      ans += (N / 2 - 1) * (magic.size() - base_index);
      break;
    } else if (lim == 3) {
      ans += N / 2 - 1 + N / 3 + (N / 3 - 1) / 2;
      continue;
    } else if (lim == 4) {
      ans += N / 2 - 1 + N / 3 + (N / 3 - 1) / 2;
      ans += 7 * N / 12;
      continue;
    }
    int cnt = 0;
    memset(vis, 0, sizeof(vis));
    for (int a = 1; a <= lim; a++) {
      for (int b = 2; b <= N; b++) {
        if (!vis[a * b]) {
          cnt++;
          vis[a * b] = 1;
        }
      }
    }
    ans += (N - 1) * lim - cnt;
  }
  printf("%lld\n", (N - 1) * (N - 1) - ans);
  clock_t end_time = clock();
  printf("%lf\n", (double)(end_time - begin_time) / CLOCKS_PER_SEC);
  return 0;
}
```
## ISTHATDISTANCE | 0.193364s | MATLAB
The solution is same as above. (but constant may be larger)
```Matlab=
clearvars,clc;
n=input("");
tic;
maxPower=floor(log2(n));
isRepeat=zeros(maxPower,n);% (i,j) represent for a^i, a^(i*j) can be repeated or not
represent=zeros(n,1);
flag=zeros(n,1);

for i=2:n
    if (flag(i))
        continue;
    else
        for j=2:floor(log(n)/log(i))
            flag(i^j)=1;
        end
    end
end
for i=2:maxPower
    for j=1:i-1
        t=lcm(i,j);
        k=1;
        while (k*t/j<=n)
            isRepeat(i,k*t/i)=1;
            k=k+1;
        end
    end
end
represent(1)=n-1;
for i=2:maxPower
    represent(i)=represent(i-1);
    for k=2:n
        represent(i)=represent(i)+1-isRepeat(i,k);
    end
end
result=int64(0);
for i=2:n
    if flag(i)
        continue;
    else
        result=result+represent(floor(log(n)/log(i)));
    end
end
disp(result);
toc;
```
Tao Lu